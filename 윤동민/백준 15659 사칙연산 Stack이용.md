## 사칙연산 Stack이용

<br>

***중위연산자(Infix Expression) 👉 후위연산자(postfix Expression)***

> **Infix Expression** = (A+B) * (C+D)
>
> **PostFix Expression** = AB+CD+*

<br>

 알고리즘으로 만들어서 계산을 하기 위해서는 ***중위연산자(Infix Expression)*** 식을 ***후위연산자(Postfix Expression)*** 식으로 바꾸어주어야 한다. 

 ***중위연산자***를 ***후위연산자***로 바꾸는 과정에서 `Stack`을 사용한다.

1️⃣ 피연산자(Operand)가 들어올 경우 출력

2️⃣ 연산자(Operator)가 들어올 경우 스택이 비었으면 Push

3️⃣ 연산자(Operator)가 들어왔을 때, 스택이 비지 않았을 경우 ➡️ 스택에 있는 연산자와 비교해 **스택의 우선순위가 같거나 크다면** 스택에 있는 연산자를 pop한 후 출력하고 현재 연산자를 Push

> ✔️ ***단, 스택에 있는 연산자를 우선순위가 크거나 같은 것이 나올때까지 계속 비교***

4️⃣ 만약 현재 연산자가 우선순위가 더 높으면 연산자(Operator)를 Push

<br>

🔴 ***괄호가 들어가 있는 경우***

1️⃣ 여는 괄호 "("인 경우 Push한다

2️⃣ 닫는 괄호인 경우 `Stack`에서 "("가 나올때까지 pop한 후 출력한다.

3️⃣ 괄호가 열리고 난 후, 우선순위를 비교할 때 여는 괄호의 우선순위는 가장 작은 것으로 취급한다.

> ✔️ 이후 과정은 위와 동일하다. Enum 타입을 사용해 각 타입별로 우선순위를 정해놓으면 편할 듯하다.

<br>

<br>

***후위연산자 계산의 경우***

1️⃣ 피연산자(Operand)가 나올 경우는 항상 Stack에 Push한다.

2️⃣ 연산자(Operator)가 나올 경우는 Stack의 최상단 2개를 Pop하여 계산한 후, 결과를 Push한다.